## 항목 2: \#define을 쓰려거든 const, enum, inline을 떠올리자
##### 가급적 선행 처리자보다 컴파일러를 더 가까이 하자
`#define ASPECT_RATIO 1.653` 을 생각해보자.
컴파일러는 이를 알지 못한다. 그저 1.653이라는 상수로 대체되어 해당 값을 읽을 뿐이다.
그래서 선행 처리자가 상수로 대체된 코드에서 컴파일 에러가 발생하면, 헷갈릴 수 있다.
(에러 메세지엔 1.653만 나오니까!)

해결법은 매크로 대신 상수를 사용하는 것이다.
`const double AspectRatio = 1.653;`  이는 언어 차원에서 지원하는 상수 타입의 데이터이고, 컴파일러도 알 수 있고 기호 테이블에도 당연히 들어간다.
상수가 부동소수점 실수 타입을 경우 메모리에서의 장점도 있을 수 있다. 1.653이 모든 곳에 들어가지 않고, 한번만 생성되기 때문.

조심할 점 2가지
- 상수 포인터를 정의하는 경우
    - 보통 상수값은 헤더파일에 정의하고, 포인터는 const 지정 + 포인터의 대상도 const로 정의한다.
    - `const char * const authorName = "Scott Meyers";`와 같이 말이다.
        - char * 보다는 string을 사용하는게 좋다.
- 클래스 멤버로 상수를 정의하는 경우 (클래스 상수)
    - 상수의 유효범위를 클래스로 한정하고자 할 때는 상수를 멤버로 만든다.
    - 사본을 한 개로 유지하려면 `static`을 사용한다.
```cpp
class GamePlayer {
private:
	static const int NumTurns = 5;
	int scores[NumTurns];
	...
};
```
NumTurns는 **선언**된 것이다. 정의가 아니다.
정적 멤버로 만들어지는 정수류 타입의 클래스 내부 상수는 예외적으로 선언만해도 가능하다.

클래스 상수의 주소를 구하거나, 컴파일러의 특이성으로 정의가 필요하다면 구현 파일에 정의한다.
`const int NumTurns;`  그러나, 상수는 선언하며 초기화되므로 초기화 하지 않는다.
(예외적으로 해당 문법이 받아들여지지 않는 컴파일러는 정의에서 초기화한다.)

당연하지만 클래스 상수를 `#define`으로 변경할 수 없다. 사용도 안되고, 캡슐화 혜택도 받을 수 없다.

앞서 말한 예외적인 상황, 즉 컴파일러가 선언 + 초기화를 허용하지 않는 경우 scores와 같은 변수는 문제가 생긴다. 즉, 클래스 상수를 초기화하지 못하는데 클래스 컴파일 중 해당 상수가 필요한 경우이다.
이를 위해 'enum hack'을 사용할 수 있다.
Enmerator 타입은 int 대신 사용할 수 있다.
```cpp
class GamePlayer {
private:
	enum { NumTurns = 5 };
	int scores[NumTurns];
	...
};
```

이 방식을 알아두면 좋다.
- 동작 방식이 const보다는 `#define`에 가깝다.
    - const의 주소를 잡아내는 것은 합당, 그러나 enum의 주소는 안된다. (define처럼)
        - 주소 접근이 싫다면 enum이 좋은 방법
    - 좋은 컴파일러는 const 객체에 대해 저장공간을 준비하지 않겠지만, 아닌 경우도 있다.
        - 보수적으로(안전하게) const에 대해 메모리를 만들지 않는다면 enum을 사용할 수 있다.
- 많은 코드에서 사용 중이기 때문에 눈을 단련해둬야 한다.
    - 템플릿 메타프로그래밍의 핵심 기법 [[Item 48]]

`#define`의 오용 사례는 매크로 함수이다.
`#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))`
이런 매크로 함수는 단점이 한두 개가 아니다.
```cpp
int a = 5, b = 0;
CALL_WITH_MAX(++a, b);
CALL_WITH_MAX(++a, b + 10);
```
이 경우 a의 ++연산이 두번 발생해 오류가 생긴다.

```cpp
template<typename T>
inline void callWithMax(const T& a, const T& b)
{
	f(a > b ? a : b);
}
```
기존 매크로의 효율은 유지하고 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취하는 방법이다.
인라인 함수에 대한 템플릿을 사용하는 것이다. [[Item 30]]
이 템플릿은 동일 계열 함수군(family of functions)를 만든다. 괄호를 덕지덕지 붙일 필요도 없고, 인자를 여러번 평가할 여지도 없다. 또 실제 함수이기 때문에 유효범위와 접근 규칙을 따라간다.
(임의의 클래스 안에서만 쓸 수 있는 인라인 함수에 대한 이야기가 나오더라도 전혀 이상하지 않다. 매크로의 경우엔 이런 말 자체가 의미가 없다.)
--> 인라인 함수를 private으로 선언할 수 있는 반면, 매크로는 당연히 불가능하다.

const, enum, inline 등을 잘 사용할 수 있음을 유념하자.
`#include #ifdef #ifndef`등 사용하는 경우가 많지만, 가능하다면 선행 처리자를 제거하는 것이 좋다.

핵심
- 단순한 상수를 쓸 땐, `#define`보다 const 객체 혹은 enum을 우선하자.
- 함수처럼 쓰이는 매크로를 만든다면, `#define`매크로보다 인라인 함수를 우선하자.
