TCP Nagle 알고리즘은 네트워크 효율성을 높이기 위해 설계된 중요한 TCP 최적화 기술

- 목적
    - 작은 패킷 증후군을 해결하는 것
    - 데이터의 양에 비해 헤더 크기가 큰 많은 소형 TCP 패킷이 전송되는 현상
- 원리
    - 한번에 하나의 작은 패킷만 전송 허용
    - 이후 작은 패킷들은 버퍼에 저장되고, 아래 상황까지 대기
        - 버퍼의 데이터가 최대 세그먼트 크기(MSS)에 도달
        - 이전에 전송된 모든 패킷의 ACK를 받았을 때
    - 이러면 작은 패킷이 큰 패킷으로 뭉쳐서 전송됨
- 장점
    - 네트워크 오버헤드 감소
        - 작은 패킷들을 합쳐 헤더 오버헤드가 줄어듦
    - 네트워크 혼잡 감소
        - 라우터와 스위치가 처리할 패킷 수가 줄어듦
    - 대역폭 효율성 향상
        - 더 많은 데이터를 전송 가능
- 단점
    - 지연 증가
        - 작은 패킷들이 즉시 전송되지 않고, 지연될 수 있음
    - 대화형 애플리케이션에는 부적합
      실시간 응답이 중요한 경우 사용자 경험이 안좋을 수도
    - ACK 지연과의 상호작용
        - TCP와 ACK 지연과 사용되면 추가 지연이 발생할 수도


    
### Half_Close
- TCP 종료 과정
    - TCP는 양방향 통신이고 종료 시, 4 way handshake를 사용함
    - 양쪽 모두 FIN 패킷을 보내고, ACK를 받습니다
    - 이때 먼저 FIN을 보낸 쪽이 상대방의 전송이 끝날 때까지 기다리는 것이 **Half Close**
- SO_LINGER 옵션
    - 소켓의 `close()` 호출 시 동작을 제어하는 TCP 소켓 옵션

    ```cpp
    struct linger {
        int l_onoff;  // 0 = off, 1 = on
        int l_linger; // linger time in seconds
    };
    ```

    - `l_onoff`가 1이고 `l_linger`가 0이면, 소켓을 강제로 닫고 남은 데이터를 버립니다(RST 패킷 전송).
    - `l_onoff`가 1이고 `l_linger`가 양수이면, 지정된 시간 동안 데이터 전송을 시도하고 시간이 지나면 강제로 닫습니다.
    - `l_onoff`가 0이면, 기본 동작을 따릅니다(백그라운드에서 데이터 전송 시도).
- Half Close 와 SO_LINGER
    - 대부분 `shutdown()` 을 사용해 구현
    - 이는 쓰기를 닫고, 읽기는 계속 가능하게 만듦
- 장점
    - 한 쪽이 데이터 전송을 완료했음을 알릴 수 있음
    - 상대 응답을 기다리며 새로운 데이터를 보내지 않음

### Graceful close
- 양쪽이 데이터 손실 없이 깔끔하게 연결을 종료하는 과정
- 특징
    - 전송 중인 모든 데이터가 성공적으로 전달
    - 연결을 닫기 전 전송 버퍼의 모든 데이터를 보냄
- TCP 4way handshake
    - 양쪽 모두 FIN을 보내고 각각에 대해 ACK를 보냄
    - 즉, a FIN → b ACK → b FIN → a ACK
- Half Close 활용
    - 클라이언트가 요청을 다 보내고 쓰기를 닫지만, 서버의 응답은 계속 받음
    - 결과적으로 SO_LINGER를 켜고 타임아웃을 길게 설정하면 Graceful Close에 도움이 됩니다.